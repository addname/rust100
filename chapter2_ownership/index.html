
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../chapter1_basics/">
      
      
        <link rel="next" href="../chapter3_collections/">
      
      
      <link rel="icon" href="../assets/螃蟹.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.18">
    
    
      
        <title>第二章：核心概念：所有权与生命周期 - Rust 100 问</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="deep-orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="Rust 100 问" class="md-header__button md-logo" aria-label="Rust 100 问" data-md-component="logo">
      
  <img src="../assets/螃蟹.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Rust 100 问
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第二章：核心概念：所有权与生命周期
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Rust 100 问" class="md-nav__button md-logo" aria-label="Rust 100 问" data-md-component="logo">
      
  <img src="../assets/螃蟹.png" alt="logo">

    </a>
    Rust 100 问
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter1_basics/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章：入门与基础
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    第二章：核心概念：所有权与生命周期
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    第二章：核心概念：所有权与生命周期
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#21-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      21. 什么是所有权 (Ownership)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-stack-heap" class="md-nav__link">
    <span class="md-ellipsis">
      22. 什么是栈 (Stack) 和堆 (Heap)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23-move" class="md-nav__link">
    <span class="md-ellipsis">
      23. 移动 (Move) 是什么意思？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24-copy" class="md-nav__link">
    <span class="md-ellipsis">
      24. 复制 (Copy) 是什么意思？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    <span class="md-ellipsis">
      25. 函数如何获得值的所有权？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26-borrowing" class="md-nav__link">
    <span class="md-ellipsis">
      26. 什么是借用 (Borrowing)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#27" class="md-nav__link">
    <span class="md-ellipsis">
      27. 不可变引用和可变引用有什么区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28" class="md-nav__link">
    <span class="md-ellipsis">
      28. 借用的核心规则是什么？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29-dangling-reference" class="md-nav__link">
    <span class="md-ellipsis">
      29. 什么是悬垂引用 (Dangling Reference)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30-slice" class="md-nav__link">
    <span class="md-ellipsis">
      30. 什么是切片 (Slice)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#31-str-string" class="md-nav__link">
    <span class="md-ellipsis">
      31. 为什么字符串切片 &amp;str 比 String 更常用作函数参数？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32-lifetimes" class="md-nav__link">
    <span class="md-ellipsis">
      32. 什么是生命周期 (Lifetimes)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    <span class="md-ellipsis">
      33. 什么时候需要手动标注生命周期？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34-a" class="md-nav__link">
    <span class="md-ellipsis">
      34. 生命周期标注 'a 是什么意思？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35-static" class="md-nav__link">
    <span class="md-ellipsis">
      35. 什么是静态生命周期 ('static)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#36" class="md-nav__link">
    <span class="md-ellipsis">
      36. 结构体中的引用也需要生命周期标注吗？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#37-borrow-checker" class="md-nav__link">
    <span class="md-ellipsis">
      37. 什么是借用检查器 (Borrow Checker)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#38" class="md-nav__link">
    <span class="md-ellipsis">
      38. 所有权、借用和生命周期三者是什么关系？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#39-copy-clone" class="md-nav__link">
    <span class="md-ellipsis">
      39. Copy 和 Clone 有什么区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40-i32-i32-copy-i32-string" class="md-nav__link">
    <span class="md-ellipsis">
      40. 为什么元组 (i32, i32) 实现了 Copy，但 (i32, String) 没有？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter3_collections/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章：复合类型与集合
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter4_advanced/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章：高级特性
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter5_concurrency/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章：并发与异步
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter6_ecosystem/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章：项目与生态
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter7_engineering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章：工程与进阶专题
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    关于
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#21-ownership" class="md-nav__link">
    <span class="md-ellipsis">
      21. 什么是所有权 (Ownership)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-stack-heap" class="md-nav__link">
    <span class="md-ellipsis">
      22. 什么是栈 (Stack) 和堆 (Heap)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23-move" class="md-nav__link">
    <span class="md-ellipsis">
      23. 移动 (Move) 是什么意思？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24-copy" class="md-nav__link">
    <span class="md-ellipsis">
      24. 复制 (Copy) 是什么意思？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    <span class="md-ellipsis">
      25. 函数如何获得值的所有权？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26-borrowing" class="md-nav__link">
    <span class="md-ellipsis">
      26. 什么是借用 (Borrowing)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#27" class="md-nav__link">
    <span class="md-ellipsis">
      27. 不可变引用和可变引用有什么区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28" class="md-nav__link">
    <span class="md-ellipsis">
      28. 借用的核心规则是什么？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29-dangling-reference" class="md-nav__link">
    <span class="md-ellipsis">
      29. 什么是悬垂引用 (Dangling Reference)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30-slice" class="md-nav__link">
    <span class="md-ellipsis">
      30. 什么是切片 (Slice)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#31-str-string" class="md-nav__link">
    <span class="md-ellipsis">
      31. 为什么字符串切片 &amp;str 比 String 更常用作函数参数？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32-lifetimes" class="md-nav__link">
    <span class="md-ellipsis">
      32. 什么是生命周期 (Lifetimes)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    <span class="md-ellipsis">
      33. 什么时候需要手动标注生命周期？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34-a" class="md-nav__link">
    <span class="md-ellipsis">
      34. 生命周期标注 'a 是什么意思？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35-static" class="md-nav__link">
    <span class="md-ellipsis">
      35. 什么是静态生命周期 ('static)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#36" class="md-nav__link">
    <span class="md-ellipsis">
      36. 结构体中的引用也需要生命周期标注吗？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#37-borrow-checker" class="md-nav__link">
    <span class="md-ellipsis">
      37. 什么是借用检查器 (Borrow Checker)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#38" class="md-nav__link">
    <span class="md-ellipsis">
      38. 所有权、借用和生命周期三者是什么关系？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#39-copy-clone" class="md-nav__link">
    <span class="md-ellipsis">
      39. Copy 和 Clone 有什么区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40-i32-i32-copy-i32-string" class="md-nav__link">
    <span class="md-ellipsis">
      40. 为什么元组 (i32, i32) 实现了 Copy，但 (i32, String) 没有？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">第二章：核心概念：所有权与生命周期</h1>
<p>所有权是 Rust 最独特的功能，它使 Rust 能够在没有垃圾回收器的情况下保证内存安全。本章将深入探讨所有权、借用、切片和生命周期这些核心概念。</p>
<hr />
<p>示意图：所有权/借用/生命周期关系</p>
<pre class="mermaid"><code>flowchart TD
  A[值 Value] --&gt;|owned by| O1[所有者 Owner]
  O1 --&gt;|move| O2[新所有者]
  O1 -.-&gt;|drop when out of scope| D[(释放内存)]
  O2 --&gt; B1[&amp;T 不可变借用]
  O2 --&gt; B2[&amp;mut T 可变借用]
  subgraph 生命周期
    B1 --&gt; L1[引用不超过被借用者]
    B2 --&gt; L1
  end</code></pre>
<h3 id="21-ownership">21. 什么是所有权 (Ownership)？</h3>
<p><strong>答：</strong>
所有权是 Rust 用来管理内存的一套规则。它解决了“谁拥有哪块内存？”以及“这块内存何时可以被释放？”这两个核心问题。所有权遵循三个基本规则：
1.  Rust 中的每一个值都有一个被称为其<strong>所有者 (owner)</strong> 的变量。
2.  值在任一时刻有且只有一个所有者。
3.  当所有者（变量）离开作用域时，这个值将被<strong>丢弃 (dropped)</strong>，其占用的内存会被释放。</p>
<hr />
<h3 id="22-stack-heap">22. 什么是栈 (Stack) 和堆 (Heap)？</h3>
<p><strong>答：</strong>
- <strong>栈 (Stack):</strong> 用于存储大小已知且固定的数据。它速度快，以“后进先出”的方式组织数据。函数调用、局部变量（如 <code>i32</code>, <code>bool</code>）通常存储在栈上。
- <strong>堆 (Heap):</strong> 用于存储在编译时大小未知或可能变化的数据。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的<strong>指针 (pointer)</strong>。这个过程称为“在堆上分配内存”。它比访问栈要慢。<code>String</code>、<code>Vec&lt;T&gt;</code> 等类型的数据存储在堆上。</p>
<p>所有权系统主要就是为了管理堆内存。</p>
<hr />
<h3 id="23-move">23. 移动 (Move) 是什么意思？</h3>
<p><strong>答：</strong>
对于存储在堆上的数据（如 <code>String</code>），当我们将它赋值给另一个变量时，所有权会发生<strong>转移 (transfer)</strong>，我们称之为“移动 (move)”。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;s1 创建后: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"> </span><span class="c1">// s1 的所有权被移动到 s2</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;移动后 s2: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// println!(&quot;{}, world!&quot;, s1); // 编译错误！s1 不再有效</span>

<span class="w">    </span><span class="c1">// 如果想要复制而不是移动，可以使用 clone</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s3</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"> </span><span class="c1">// 深拷贝</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;s3: {}, s4: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">);</span><span class="w"> </span><span class="c1">// 两个都有效</span>

<span class="w">    </span><span class="c1">// 演示移动后的变量状态</span>
<span class="w">    </span><span class="n">demonstrate_move</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_move</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;I will be moved&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">moved_to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">take_ownership</span><span class="p">(</span><span class="n">original</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// println!(&quot;{}&quot;, original); // 编译错误：original 已被移动</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;函数返回: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">moved_to</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">take_ownership</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;函数内部: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="c1">// 返回所有权</span>
<span class="p">}</span>
</code></pre></div>
为了保证内存安全（防止二次释放），一旦所有权转移，原来的变量（<code>s1</code>）就不能再被使用。</p>
<hr />
<h3 id="24-copy">24. 复制 (Copy) 是什么意思？</h3>
<p><strong>答：</strong>
对于完全存储在栈上的数据（如 <code>i32</code>, <code>bool</code>, <code>char</code> 等基本类型），当我们将它赋值给另一个变量时，会创建一个完整的副本。这被称为“复制 (copy)”。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 基本类型的复制</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// x 的值被复制到 y</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;复制后: x = {}, y = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// 正确！x 和 y 都有效</span>

<span class="w">    </span><span class="c1">// 多种 Copy 类型示例</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;R&#39;</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复制</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复制</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复制</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">d2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复制</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;原始值仍然有效:&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a = {}, b = {}, c = {}, d = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;复制的值:&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a2 = {}, b2 = {}, c2 = {}, d2 = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 元组的复制（如果所有元素都实现了 Copy）</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复制</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;tuple1: {:?}, tuple2: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tuple1</span><span class="p">,</span><span class="w"> </span><span class="n">tuple2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 数组的复制（如果元素实现了 Copy 且长度适中）</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复制</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;arr1: {:?}, arr2: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr1</span><span class="p">,</span><span class="w"> </span><span class="n">arr2</span><span class="p">);</span>

<span class="w">    </span><span class="n">demonstrate_copy_in_functions</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_copy_in_functions</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">square</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;原始值 {} 在函数调用后仍然有效&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;平方结果: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
</code></pre></div>
如果一个类型实现了 <code>Copy</code> trait，那么它的变量在赋值时就不会被移动，而是被复制。</p>
<hr />
<h3 id="25">25. 函数如何获得值的所有权？</h3>
<p><strong>答：</strong>
将变量传递给函数与将其赋值给另一个变量类似。
- 对于实现了 <code>Copy</code> 的类型，值会被复制。
- 对于没有实现 <code>Copy</code> 的类型（如 <code>String</code>），所有权会被移动。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 所有权转移示例</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;调用函数前: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="w">    </span><span class="n">takes_ownership</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">// s 的所有权移动到函数里</span>
<span class="w">    </span><span class="c1">// println!(&quot;{}&quot;, s); // 编译错误！s 已失效</span>

<span class="w">    </span><span class="c1">// Copy 类型示例</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;调用函数前: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="n">makes_copy</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// x 的值被复制到函数里</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;调用函数后: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// 正确！x 仍然有效</span>

<span class="w">    </span><span class="c1">// 函数返回所有权</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gives_ownership</span><span class="p">();</span><span class="w"> </span><span class="c1">// 函数返回值的所有权转移给 s1</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;从函数获得: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">takes_and_gives_back</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span><span class="w"> </span><span class="c1">// s2 移入函数，返回值移给 s3</span>
<span class="w">    </span><span class="c1">// println!(&quot;{}&quot;, s2); // 编译错误！s2 已失效</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;取回的值: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 演示多个变量的所有权转移</span>
<span class="w">    </span><span class="n">demonstrate_multiple_ownership</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">takes_ownership</span><span class="p">(</span><span class="n">some_string</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;函数接收到: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">some_string</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// some_string 在这里被 drop</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">makes_copy</span><span class="p">(</span><span class="n">some_integer</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;函数接收到: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">some_integer</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// some_integer 在这里超出作用域，但因为是 Copy，没有特殊处理</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">gives_ownership</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">some_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;函数创建的字符串&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">some_string</span><span class="w"> </span><span class="c1">// 返回 some_string，所有权移出函数</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">takes_and_gives_back</span><span class="p">(</span><span class="n">a_string</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;函数处理: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span>
<span class="w">    </span><span class="n">a_string</span><span class="w"> </span><span class="c1">// 返回 a_string，所有权移出函数</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_multiple_ownership</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;first&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;second&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;third&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_lengths</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;返回的字符串: {}, {}, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;总长度: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">calculate_lengths</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s2</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s3</span><span class="p">.</span><span class="n">len</span><span class="p">();</span>
<span class="w">    </span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
函数也可以返回值，从而将所有权交还给调用者。</p>
<hr />
<h3 id="26-borrowing">26. 什么是借用 (Borrowing)？</h3>
<p><strong>答：</strong>
如果我们希望在不转移所有权的情况下让函数使用某个值，我们可以传递它的<strong>引用 (reference)</strong>。这个过程称为“借用”。引用使用 <code>&amp;</code> 符号。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 基本借用示例</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 传递 s1 的引用</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;字符串 &#39;{}&#39; 的长度是 {}.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"> </span><span class="c1">// 正确！s1 仍然有效</span>

<span class="w">    </span><span class="c1">// 多次借用</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;字符串 &#39;{}&#39; 可以被多次借用: {}, {}, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">len1</span><span class="p">,</span><span class="w"> </span><span class="n">len2</span><span class="p">,</span><span class="w"> </span><span class="n">len3</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 不同类型的借用</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numbers</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count_elements</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numbers</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;数组 {:?} 的和: {}, 元素个数: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">numbers</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 借用数组切片</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// 借用切片</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;切片 {:?} 的和: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">slice_sum</span><span class="p">);</span>

<span class="w">    </span><span class="n">demonstrate_reference_rules</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// s 在这里超出作用域，但因为它不拥有引用值，所以不会 drop</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">calculate_sum</span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">sum</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">count_elements</span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">sum_slice</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">slice</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_reference_rules</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;reference rules&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 可以同时有多个不可变引用</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;多个不可变引用: {}, {}, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 引用的作用域</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;作用域内的引用: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">r4</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// r4 在这里超出作用域</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;原始字符串仍然有效: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
通过引用，<code>calculate_length</code> 函数“借用”了 <code>s1</code>，但并没有获得其所有权。</p>
<p>示意图：所有权传递与借用调用链</p>
<pre class="mermaid"><code>sequenceDiagram
    participant Main
    participant Func as takes_ownership
    participant Borrow as calculate_length
    Main-&gt;&gt;Func: move String(s)
    Func--&gt;&gt;Main: (所有权不回退)
    Main-&gt;&gt;Borrow: &amp;String(s) 借用
    Borrow--&gt;&gt;Main: 长度 (所有权仍在 Main)</code></pre>
<hr />
<h3 id="27">27. 不可变引用和可变引用有什么区别？</h3>
<p><strong>答：</strong>
- <strong>不可变引用 (Immutable Reference):</strong> <code>&amp;T</code>。它允许你读取数据，但不能修改它。
- <strong>可变引用 (Mutable Reference):</strong> <code>&amp;mut T</code>。它允许你修改借用的数据。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 可变借用示例</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;原始字符串: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 可变借用</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="n">r1</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&quot;, world&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;可变借用修改后: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// r1 在这里超出作用域</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;修改后的原字符串: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 演示借用规则</span>
<span class="w">    </span><span class="n">demonstrate_borrowing_rules</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 可变引用的实际应用</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;修改前: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">numbers</span><span class="p">);</span>

<span class="w">    </span><span class="n">modify_vector</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">numbers</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;修改后: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">numbers</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 通过可变引用交换值</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;交换前: a = {}, b = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="n">swap_values</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;交换后: a = {}, b = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_borrowing_rules</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;borrowing rules&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 规则1: 同一时间只能有一个可变引用</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="n">r1</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&quot; - rule 1&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;可变引用: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// let r2 = &amp;mut s; // 编译错误！不能同时有两个可变引用</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 规则2: 可变引用和不可变引用不能同时存在</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不可变引用</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// 另一个不可变引用</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;不可变引用: {}, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// let r3 = &amp;mut s; // 编译错误！不能在有不可变引用时创建可变引用</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 规则3: 引用必须总是有效的</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;有效的引用: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">modify_vector</span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// 修改第一个元素</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">swap_values</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h3 id="28">28. 借用的核心规则是什么？</h3>
<p><strong>答：</strong>
借用有两条非常重要的规则，由编译器强制执行：
1.  在任意给定时间，你要么只能拥有<strong>一个</strong>可变引用，要么只能拥有<strong>任意数量</strong>的不可变引用。
2.  引用必须总是有效的。</p>
<p>这套规则在编译时就防止了“数据竞争”（Data Races），即多个指针同时访问同一数据，其中至少一个在写，且没有同步机制。</p>
<hr />
<h3 id="29-dangling-reference">29. 什么是悬垂引用 (Dangling Reference)？</h3>
<p><strong>答：</strong>
悬垂引用是指一个指向了无效内存地址的指针，这块内存可能已经被释放并另作他用。在很多语言中，这是一个常见的严重 bug。</p>
<p>Rust 的编译器通过所有权和借用规则<strong>保证你永远不会遇到悬垂引用</strong>。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// fn dangle() -&gt; &amp;String { // dangle 返回一个 String 的引用</span>
<span class="c1">//     let s = String::from(&quot;hello&quot;); // s 在这里创建</span>
<span class="c1">//     &amp;s // 我们返回 s 的引用</span>
<span class="c1">// } // s 在这里离开作用域，内存被释放。引用将指向无效内存！</span>
<span class="c1">// 上述代码无法通过编译！</span>
</code></pre></div>
<hr />
<h3 id="30-slice">30. 什么是切片 (Slice)？</h3>
<p><strong>答：</strong>
切片允许你引用集合中一段连续的元素序列，而不用引用整个集合。切片也是一种引用，所以它没有所有权。</p>
<p>最常见的切片是字符串切片 <code>&amp;str</code>。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 基本字符串切片</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;原始字符串: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span><span class="w"> </span><span class="c1">// &quot;hello&quot;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">11</span><span class="p">];</span><span class="w"> </span><span class="c1">// &quot;world&quot;</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;切片: &#39;{}&#39; 和 &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">hello</span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 切片语法的各种形式</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"> </span><span class="c1">// 整个字符串</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">from_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span><span class="w"> </span><span class="c1">// 从开始到索引5</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">to_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="p">];</span><span class="w"> </span><span class="c1">// 从索引6到结束</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;完整: &#39;{}&#39;, 开始: &#39;{}&#39;, 结尾: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">full</span><span class="p">,</span><span class="w"> </span><span class="n">from_start</span><span class="p">,</span><span class="w"> </span><span class="n">to_end</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 数组切片</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="c1">// [2, 3, 4]</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;数组: {:?}, 切片: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 字符串字面量就是切片</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello, Rust!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 类型是 &amp;str</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;字符串字面量: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">literal</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 切片作为函数参数</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;第一个单词: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="s">&quot;rust programming&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;字面量的第一个单词: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 可变切片</span>
<span class="w">    </span><span class="n">demonstrate_mutable_slices</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 切片的实际应用</span>
<span class="w">    </span><span class="n">demonstrate_slice_applications</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">first_word</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">b&#39; &#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_mutable_slices</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;原始数组: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">        </span><span class="n">slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="w">        </span><span class="n">slice</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;修改切片后: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;修改后的数组: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">demonstrate_slice_applications</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 在函数中使用切片提高灵活性</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;rust programming&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;字符串长度: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">get_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">));</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;字面量长度: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">get_length</span><span class="p">(</span><span class="n">s2</span><span class="p">));</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;数组切片和: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="o">..</span><span class="p">]));</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;部分切片和: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]));</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">get_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">sum_slice</span><span class="p">(</span><span class="n">slice</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">sum</span>
<span class="p">}</span>
</code></pre></div>
字符串字面量（如 <code>"hello"</code>）本身就是切片类型 (<code>&amp;'static str</code>)。</p>
<hr />
<h3 id="31-str-string">31. 为什么字符串切片 <code>&amp;str</code> 比 <code>String</code> 更常用作函数参数？</h3>
<p><strong>答：</strong>
通过接受 <code>&amp;str</code> 作为参数，你的函数可以变得更通用。这样的函数既可以接受 <code>String</code> 类型（通过 <code>&amp;my_string[..]</code> 或直接 <code>&amp;my_string</code>），也可以接受字符串字面量 (<code>"a literal"</code>)。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 通用性强的函数</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">first_word</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">first_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// 传入 String 的切片</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">first_word</span><span class="p">(</span><span class="n">my_literal</span><span class="p">);</span><span class="w"> </span><span class="c1">// 传入字符串字面量</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h3 id="32-lifetimes">32. 什么是生命周期 (Lifetimes)？</h3>
<p><strong>答：</strong>
生命周期是 Rust 编译器（借用检查器）用来确保所有借用都有效的范围。大多数时候，生命周期是隐式和被推断的，就像类型推断一样。但当引用的生命周期可能以多种方式关联时，你就必须手动标注生命周期。</p>
<p>生命周期的核心任务是防止悬垂引用。</p>
<hr />
<h3 id="33">33. 什么时候需要手动标注生命周期？</h3>
<p><strong>答：</strong>
当你编写的函数或结构体接受或返回引用时，如果编译器无法根据其三条“生命周期省略规则”来推断出引用的有效范围，你就需要手动标注。</p>
<p>最常见的情况是：一个函数返回一个引用，而这个引用的生命周期来自于函数传入的多个引用之一。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 编译器不知道返回的引用是来自 x 还是 y</span>
<span class="c1">// 所以我们需要手动标注</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">longest</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">y</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h3 id="34-a">34. 生命周期标注 <code>'a</code> 是什么意思？</h3>
<p><strong>答：</strong>
生命周期标注（如 <code>'a</code>）本身不会改变任何引用的存活时间。它更像是一个<strong>泛型参数</strong>，用来告诉编译器多个引用之间生命周期的关系。</p>
<p>在 <code>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str</code> 中：
- <code>'a</code> 是一个生命周期参数的声明。
- <code>x: &amp;'a str</code> 表示 <code>x</code> 是一个生命周期至少和 <code>'a</code> 一样长的引用。
- <code>y: &amp;'a str</code> 表示 <code>y</code> 也是一个生命周期至少和 <code>'a</code> 一样长的引用。
- <code>-&gt; &amp;'a str</code> 表示函数返回的引用，其生命周期也至少和 <code>'a</code> 一样长。</p>
<p>这实际上是告诉编译器：“返回的这个引用的有效范围，受限于 <code>x</code> 和 <code>y</code> 中<strong>较短</strong>的那个生命周期”。</p>
<hr />
<h3 id="35-static">35. 什么是静态生命周期 (<code>'static</code>)？</h3>
<p><strong>答：</strong>
<code>'static</code> 是一个特殊的生命周期，它意味着被引用的数据在<strong>整个程序的运行期间</strong>都有效。</p>
<p>所有字符串字面量都拥有 <code>'static</code> 生命周期，因为它们被直接存储在程序的可执行文件里。</p>
<p><div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I have a static lifetime.&quot;</span><span class="p">;</span>
</code></pre></div>
只有当你知道数据会一直存在时，才应该使用它。在函数参数或返回值中要求 <code>'static</code> 生命周期是一个很强的约束，需要谨慎使用。</p>
<hr />
<h3 id="36">36. 结构体中的引用也需要生命周期标注吗？</h3>
<p><strong>答：</strong>
是的。如果一个结构体持有引用，那么它的定义必须包含生命周期标注，这样每个引用的生命周期才能和结构体实例的生命周期关联起来。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ImportantExcerpt</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">part</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">novel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Call me Ishmael. Some years ago...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first_sentence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">novel</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">).</span><span class="n">next</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Could not find a &#39;.&#39;&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// i 的生命周期不能超过 first_sentence 的生命周期</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImportantExcerpt</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">part</span><span class="p">:</span><span class="w"> </span><span class="nc">first_sentence</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
这保证了 <code>ImportantExcerpt</code> 的实例不会比它所引用的数据活得更久。</p>
<hr />
<h3 id="37-borrow-checker">37. 什么是借用检查器 (Borrow Checker)？</h3>
<p><strong>答：</strong>
借用检查器是 Rust 编译器的一部分。它在编译时工作，比较作用域和生命周期，以确保所有的借用都是有效的。如果违反了借用规则（例如，可能产生悬垂引用或数据竞争），借用检查器会拒绝编译代码。</p>
<p>正是借用检查器让 Rust 能够在没有垃圾回收的情况下实现内存安全。</p>
<hr />
<h3 id="38">38. 所有权、借用和生命周期三者是什么关系？</h3>
<p><strong>答：</strong>
它们是 Rust 内存安全保证的三大支柱，紧密相连：
- <strong>所有权</strong> 确立了谁负责清理数据。
- <strong>借用</strong> 允许你在不转移所有权的情况下临时访问数据。
- <strong>生命周期</strong> 是一套编译器用来确保借用（引用）不会比它们所指向的数据活得更久的规则。</p>
<p>你可以把它们想象成：所有权是房产证，借用是把钥匙借给朋友，生命周期是确保朋友不会在房子被拆了之后还想用钥匙开门。</p>
<hr />
<h3 id="39-copy-clone">39. <code>Copy</code> 和 <code>Clone</code> 有什么区别？</h3>
<p><strong>答：</strong>
- <strong><code>Copy</code></strong>: 是一种特殊的 <code>Clone</code>。如果一个类型实现了 <code>Copy</code>，那么它在赋值时会发生“按位复制”，这是一个非常廉价的操作，并且不会移动所有权。它只能用于完全存储在栈上的数据。
- <strong><code>Clone</code></strong>: 是一个更通用的 trait。<code>clone()</code> 方法允许你显式地创建一个值的深拷贝（deep copy）。对于堆上的数据（如 <code>String</code>），<code>clone()</code> 会分配新的堆内存并复制数据。这是一个可能开销较大的操作。</p>
<p>所有实现了 <code>Copy</code> 的类型也都实现了 <code>Clone</code>。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"> </span><span class="c1">// 显式克隆，开销较大</span>

<span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// i32 实现了 Copy</span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 隐式复制，开销极小</span>
</code></pre></div>
<hr />
<h3 id="40-i32-i32-copy-i32-string">40. 为什么元组 <code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 没有？</h3>
<p><strong>答：</strong>
一个复合类型（如元组或结构体）能否实现 <code>Copy</code>，取决于它的所有成员是否都实现了 <code>Copy</code>。
- <code>(i32, i32)</code>: <code>i32</code> 实现了 <code>Copy</code>，所以由 <code>i32</code> 组成的元组也实现了 <code>Copy</code>。
- <code>(i32, String)</code>: <code>String</code> 没有实现 <code>Copy</code>（因为它管理堆内存），所以任何包含 <code>String</code> 的元组都不能实现 <code>Copy</code>。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="https://unpkg.com/mermaid@10/dist/mermaid.min.js"></script>
      
        <script src="../assets/mermaid-init.js"></script>
      
    
  </body>
</html>