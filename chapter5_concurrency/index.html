
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../chapter4_advanced/">
      
      
        <link rel="next" href="../chapter6_ecosystem/">
      
      
      <link rel="icon" href="../assets/螃蟹.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.18">
    
    
      
        <title>第五章：并发与异步 - Rust 100 问</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="deep-orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="Rust 100 问" class="md-header__button md-logo" aria-label="Rust 100 问" data-md-component="logo">
      
  <img src="../assets/螃蟹.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Rust 100 问
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第五章：并发与异步
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Rust 100 问" class="md-nav__button md-logo" aria-label="Rust 100 问" data-md-component="logo">
      
  <img src="../assets/螃蟹.png" alt="logo">

    </a>
    Rust 100 问
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter1_basics/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章：入门与基础
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter2_ownership/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章：核心概念：所有权与生命周期
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter3_collections/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章：复合类型与集合
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter4_advanced/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章：高级特性
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    第五章：并发与异步
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    第五章：并发与异步
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#76-rust" class="md-nav__link">
    <span class="md-ellipsis">
      76. 如何在 Rust 中创建一个新线程？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#77-threadspawn-move" class="md-nav__link">
    <span class="md-ellipsis">
      77. 为什么在 thread::spawn 中经常使用 move 闭包？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#78-channel" class="md-nav__link">
    <span class="md-ellipsis">
      78. 什么是通道 (Channel)？它如何用于线程间通信？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#79-mutex" class="md-nav__link">
    <span class="md-ellipsis">
      79. 什么是互斥锁 (Mutex)？如何使用它在线程间共享状态？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#80-arct-mutext" class="md-nav__link">
    <span class="md-ellipsis">
      80. Arc&lt;T&gt; 是什么？为什么它经常和 Mutex&lt;T&gt; 一起使用？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#81-send-sync-trait" class="md-nav__link">
    <span class="md-ellipsis">
      81. Send 和 Sync trait 有什么作用？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#82-async-programming" class="md-nav__link">
    <span class="md-ellipsis">
      82. 什么是异步编程 (Async Programming)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#83-async-await" class="md-nav__link">
    <span class="md-ellipsis">
      83. async 和 await 关键字是做什么用的？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#84-future" class="md-nav__link">
    <span class="md-ellipsis">
      84. 什么是 Future？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#85-async-runtime" class="md-nav__link">
    <span class="md-ellipsis">
      85. 什么是异步运行时 (Async Runtime)？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter6_ecosystem/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章：项目与生态
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../chapter7_engineering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章：工程与进阶专题
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    关于
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#76-rust" class="md-nav__link">
    <span class="md-ellipsis">
      76. 如何在 Rust 中创建一个新线程？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#77-threadspawn-move" class="md-nav__link">
    <span class="md-ellipsis">
      77. 为什么在 thread::spawn 中经常使用 move 闭包？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#78-channel" class="md-nav__link">
    <span class="md-ellipsis">
      78. 什么是通道 (Channel)？它如何用于线程间通信？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#79-mutex" class="md-nav__link">
    <span class="md-ellipsis">
      79. 什么是互斥锁 (Mutex)？如何使用它在线程间共享状态？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#80-arct-mutext" class="md-nav__link">
    <span class="md-ellipsis">
      80. Arc&lt;T&gt; 是什么？为什么它经常和 Mutex&lt;T&gt; 一起使用？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#81-send-sync-trait" class="md-nav__link">
    <span class="md-ellipsis">
      81. Send 和 Sync trait 有什么作用？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#82-async-programming" class="md-nav__link">
    <span class="md-ellipsis">
      82. 什么是异步编程 (Async Programming)？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#83-async-await" class="md-nav__link">
    <span class="md-ellipsis">
      83. async 和 await 关键字是做什么用的？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#84-future" class="md-nav__link">
    <span class="md-ellipsis">
      84. 什么是 Future？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#85-async-runtime" class="md-nav__link">
    <span class="md-ellipsis">
      85. 什么是异步运行时 (Async Runtime)？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">第五章：并发与异步</h1>
<p>Rust 提供了强大的工具来安全地编写并发甚至并行的代码。它的所有权和类型系统在编译时就为你解决了许多常见的并发问题。本章将介绍线程、消息传递、共享状态以及 Rust 的 <code>async/await</code> 语法。</p>
<hr />
<p>示意图：并发与异步模型</p>
<pre class="mermaid"><code>flowchart LR
  T[Threads] --&gt; M[消息传递 mpsc]
  T --&gt; S[共享状态 Arc&lt;Mutex&gt;]
  subgraph Async Runtime
    E[Executor 执行器] --&gt; P[Poll Futures]
    R[Reactor 反应器] --&gt;|I/O 事件| E
  end
  Async[async/await] --&gt; E</code></pre>
<h3 id="76-rust">76. 如何在 Rust 中创建一个新线程？</h3>
<p><strong>答：</strong>
使用 <code>std::thread::spawn</code> 函数。它接受一个闭包作为参数，这个闭包包含了你想在新线程中运行的代码。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="c1">// 创建一个新线程</span>
<span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;hi number {} from the spawned thread!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">thread</span><span class="p">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>

<span class="c1">// 主线程的代码会继续执行</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;hi number {} from the main thread!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">thread</span><span class="p">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 等待新线程执行完毕</span>
<span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
</code></pre></div>
<code>spawn</code> 函数返回一个 <code>JoinHandle</code>，调用它的 <code>join</code> 方法可以阻塞当前线程，直到被调用的线程执行完毕。</p>
<hr />
<h3 id="77-threadspawn-move">77. 为什么在 <code>thread::spawn</code> 中经常使用 <code>move</code> 闭包？</h3>
<p><strong>答：</strong>
因为 <code>thread::spawn</code> 创建的新线程可能会比创建它的主线程活得更久。为了保证新线程中引用的数据是有效的，我们需要将这些数据的所有权<strong>移动</strong>到新线程中。</p>
<p><code>move</code> 关键字强制闭包获取它所使用的所有环境变量的所有权。这是一种向 Rust 编译器保证，该闭包不会意外地引用一个可能在未来被主线程释放掉的变量。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="c1">// `move` 将 v 的所有权转移到新线程</span>
<span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Here&#39;s a vector: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// drop(v); // 如果在这里尝试使用 v，会编译错误，因为所有权已经转移</span>

<span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
</code></pre></div>
<hr />
<h3 id="78-channel">78. 什么是通道 (Channel)？它如何用于线程间通信？</h3>
<p><strong>答：</strong>
通道是 Rust 中一种常见的、用于线程间<strong>消息传递</strong>的编程模型。你可以把它想象成一个单向的管道：一端是发送者 (Transmitter)，另一端是接收者 (Receiver)。</p>
<p>Rust 的标准库在 <code>std::sync::mpsc</code> 模块中提供了通道的实现。<code>mpsc</code> 代表“多个生产者，单个消费者”（multiple producer, single consumer）。</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">();</span><span class="w"> </span><span class="c1">// tx 是发送者, rx 是接收者</span>

<span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">val</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// send 会获取所有权</span>
<span class="p">});</span>

<span class="kd">let</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// recv 会阻塞主线程直到接收到消息</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Got: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">received</span><span class="p">);</span>
</code></pre></div>
<p>示意图：多生产者通道</p>
<pre class="mermaid"><code>flowchart LR
  P1[tx1] --&gt; CH[(channel)]
  P2[tx2] --&gt; CH
  P3[tx3] --&gt; CH
  CH --&gt; RX[rx]</code></pre>
<p>进阶示例：多个生产者与接收循环、超时接收
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 多个生产者：克隆发送端</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">tx_clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="w">        </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;producer#{id} -&gt; {i}&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="n">tx_clone</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="n">thread</span><span class="p">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span><span class="w"> </span><span class="c1">// 关闭原始发送端，确保接收端在生产者结束后退出循环</span>

<span class="w">    </span><span class="c1">// 接收循环</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;recv: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 使用 recv_timeout 等待一段时间</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx2</span><span class="p">,</span><span class="w"> </span><span class="n">rx2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">();</span>
<span class="w">    </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">thread</span><span class="p">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">200</span><span class="p">)));</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">rx2</span><span class="p">.</span><span class="n">recv_timeout</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;got {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;timeout or closed: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<hr />
<h3 id="79-mutex">79. 什么是互斥锁 (Mutex)？如何使用它在线程间共享状态？</h3>
<p><strong>答：</strong>
互斥锁（Mutex, mutual exclusion）是一种只允许一个线程在任意时刻访问某些数据的机制。要访问数据，线程必须首先获取互斥锁的“锁”（lock）。当线程使用完数据后，它必须“解锁”（unlock），这样其他线程才能获取锁并访问数据。</p>
<p>在 Rust 中，我们使用 <code>std::sync::Mutex&lt;T&gt;</code>。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::</span><span class="n">Mutex</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// 获取锁，返回一个 MutexGuard</span>
<span class="w">    </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// 锁在这里被自动释放</span>

<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;m = {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span>
</code></pre></div>
<code>lock()</code> 方法返回的是一个智能指针 <code>MutexGuard</code>。当 <code>MutexGuard</code> 离开作用域时，锁会自动被释放。这极大地避免了忘记解锁导致的死锁问题。</p>
<hr />
<p>进阶示例：<code>RwLock</code> 与锁毒化处理
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::{</span><span class="n">RwLock</span><span class="p">,</span><span class="w"> </span><span class="n">PoisonError</span><span class="p">};</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RwLock</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// 多个读者</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;reads: {:?}, {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 写者</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">write</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">w</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 锁毒化示例</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RwLock</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">panic</span><span class="p">::</span><span class="n">catch_unwind</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bad</span><span class="p">.</span><span class="n">write</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="o">*</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">        </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;oops&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">is_err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">recovered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">bad</span><span class="p">.</span><span class="n">write</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">,</span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">PoisonError</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 恢复访问毒化的锁</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bad</span><span class="p">.</span><span class="n">write</span><span class="p">().</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">into_inner</span><span class="p">());</span>
<span class="w">                </span><span class="o">*</span><span class="n">g</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;recovered value = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">recovered</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="80-arct-mutext">80. <code>Arc&lt;T&gt;</code> 是什么？为什么它经常和 <code>Mutex&lt;T&gt;</code> 一起使用？</h3>
<p><strong>答：</strong>
<code>Arc&lt;T&gt;</code> 是<strong>原子引用计数 (Atomically Reference Counted)</strong> 智能指针。它和 <code>Rc&lt;T&gt;</code> 功能类似，都允许多个所有者共享数据，但 <code>Arc&lt;T&gt;</code> 是<strong>线程安全</strong>的。</p>
<ul>
<li>当你想在多个线程之间共享数据的所有权时，<code>Arc&lt;T&gt;</code> 是必需的。<code>Rc&lt;T&gt;</code> 不能被安全地在线程间传递。</li>
<li><code>Mutex&lt;T&gt;</code> 保证了在任意时刻只有一个线程能修改数据。</li>
<li>但是 <code>Mutex&lt;T&gt;</code> 本身并不允许多个所有者。</li>
</ul>
<p>因此，<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 是一个非常强大的组合：
- <code>Arc&lt;T&gt;</code> 允许多个线程“拥有”指向互斥锁的指针。
- <code>Mutex&lt;T&gt;</code> 保证了对内部数据的访问是互斥的、线程安全的。</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::{</span><span class="n">Mutex</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span><span class="p">};</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">Mutex</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>

<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span><span class="p">::</span><span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">handles</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">handles</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="p">}</span>

<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Result: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w"> </span><span class="c1">// 打印 10</span>
</code></pre></div>
<p>示意图：Arc<Mutex\<T>> 共享计数器</p>
<pre class="mermaid"><code>flowchart LR
  subgraph 堆
    M[Mutex&lt;T&gt;]
  end
  A[Arc] --&gt; M
  B[Arc] --&gt; M
  C[Arc] --&gt; M</code></pre>
<hr />
<p>进阶示例：简单线程池（工作窃取的极简雏形）
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::{</span><span class="n">Arc</span><span class="p">,</span><span class="w"> </span><span class="n">Mutex</span><span class="p">,</span><span class="w"> </span><span class="n">mpsc</span><span class="p">};</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">Job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">static</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ThreadPool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">workers</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">sender</span><span class="p">:</span><span class="w"> </span><span class="nc">mpsc</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">ThreadPool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">Mutex</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">rx</span><span class="p">));</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">workers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">size</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span><span class="p">::</span><span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="p">);</span>
<span class="w">            </span><span class="n">workers</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">job</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">job</span><span class="p">(),</span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">workers</span><span class="p">,</span><span class="w"> </span><span class="n">sender</span><span class="p">:</span><span class="w"> </span><span class="nc">tx</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">execute</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">F</span><span class="p">)</span>
<span class="w">    </span><span class="k">where</span>
<span class="w">        </span><span class="n">F</span><span class="p">:</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">static</span><span class="p">,</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">f</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="81-send-sync-trait">81. <code>Send</code> 和 <code>Sync</code> trait 有什么作用？</h3>
<p><strong>答：</strong>
<code>Send</code> 和 <code>Sync</code> 是两个特殊的标记 trait，它们是 Rust 并发模型的核心。</p>
<ul>
<li><strong><code>Send</code></strong>: 如果一个类型 <code>T</code> 实现了 <code>Send</code>，意味着 <code>T</code> 类型的值的所有权可以被安全地<strong>在线程间传递</strong>。几乎所有 Rust 类型都实现了 <code>Send</code>，主要的例外是 <code>Rc&lt;T&gt;</code> 和原始指针。</li>
<li><strong><code>Sync</code></strong>: 如果一个类型 <code>T</code> 实现了 <code>Sync</code>，意味着 <code>&amp;T</code>（对 <code>T</code> 的不可变引用）可以被安全地<strong>在线程间共享</strong>。换句话说，如果 <code>&amp;T</code> 是 <code>Send</code> 的，那么 <code>T</code> 就是 <code>Sync</code> 的。</li>
</ul>
<p>这两个 trait 是自动为组合了 <code>Send</code> 和 <code>Sync</code> 类型的复合类型实现的。你不需要手动去实现它们，但它们保证了 Rust 的并发安全性是在编译时就被检查的。</p>
<hr />
<h3 id="82-async-programming">82. 什么是异步编程 (Async Programming)？</h3>
<p><strong>答：</strong>
异步编程是一种允许程序在等待一个长时间操作（如文件读写、网络请求）完成时，可以继续执行其他任务的编程范式。它通过非阻塞的方式来提高程序的效率和响应能力。</p>
<p>在传统的同步代码中，当一个函数等待 I/O 时，整个线程都会被阻塞。在异步代码中，当一个任务需要等待时，它可以将控制权交还给运行时（runtime），运行时则可以去执行另一个已经准备好的任务。</p>
<hr />
<h3 id="83-async-await">83. <code>async</code> 和 <code>await</code> 关键字是做什么用的？</h3>
<p><strong>答：</strong>
<code>async</code> 和 <code>await</code> 是 Rust 中进行异步编程的两个核心关键字。</p>
<ul>
<li><strong><code>async</code></strong>: 当你用 <code>async</code> 标记一个函数时，它会把这个函数变成一个返回<strong>Future</strong>的函数。Future 是一个代表未来某个时刻才会完成的值。<code>async</code> 函数本身并不会执行，它只是构建一个 Future。</li>
<li><strong><code>await</code></strong>: 当你在一个 Future 上使用 <code>.await</code> 时，它会暂停当前 <code>async</code> 函数的执行，直到这个 Future 完成。在暂停期间，线程不会被阻塞，而是可以去执行其他任务。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">do_something</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Going to do something&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 模拟一个异步操作</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_async_operation</span><span class="p">().</span><span class="k">await</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Got result: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>进阶示例（Tokio）：并发任务、select 与超时、取消
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">tokio</span><span class="p">::</span><span class="n">time</span><span class="p">::{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Duration</span><span class="p">};</span>

<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">time</span><span class="p">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">50</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">)).</span><span class="k">await</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span>
<span class="p">}</span>

<span class="cp">#[tokio::main]</span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 并发执行多个任务</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokio</span><span class="p">::</span><span class="n">join</span><span class="o">!</span><span class="p">(</span><span class="n">work</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;results: {}, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 超时</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">::</span><span class="n">timeout</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_millis</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="k">await</span><span class="p">;</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;timeout result: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// select 选择先完成的任务</span>
<span class="w">    </span><span class="n">tokio</span><span class="p">::</span><span class="n">select</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;first done: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">),</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;second done&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 取消：丢弃 future 即可</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">fut</span><span class="p">);</span><span class="w"> </span><span class="c1">// 被取消，不会完成</span>
<span class="p">}</span>
</code></pre></div></p>
<hr />
<h3 id="84-future">84. 什么是 Future？</h3>
<p><strong>答：</strong>
<code>Future</code> 是一个 trait，它代表一个可以被轮询（polled）的异步计算。它只有一个 <code>poll</code> 方法。</p>
<p><div class="highlight"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Output</span><span class="p">;</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span><span class="w"> </span><span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
当一个 future 被 <code>poll</code> 时，它会尝试取得进展。<code>poll</code> 方法会返回：
- <code>Poll::Ready(value)</code>: 表示 future 已经完成，并产出了一个值。
- <code>Poll::Pending</code>: 表示 future 还没有准备好，它会在准备好时通过 <code>Context</code> 通知执行器再次轮询它。</p>
<p>你通常不需要手动实现 <code>Future</code> trait，<code>async/await</code> 语法会为你自动生成。</p>
<hr />
<h3 id="85-async-runtime">85. 什么是异步运行时 (Async Runtime)？</h3>
<p><strong>答：</strong>
异步运行时是一个库，它负责执行异步代码。它包含一个<strong>执行器 (executor)</strong>，负责接收顶层的 Future (<code>async</code> 函数)，并通过不断轮询（poll）来驱动它们直到完成。它还包含一个<strong>反应器 (reactor)</strong>，负责处理外部 I/O 事件（如网络套接字准备好读写），并在事件发生时唤醒相应的 Future。</p>
<p>Rust 语言本身只提供了 <code>async/await</code> 语法和 <code>Future</code> trait，但<strong>没有</strong>内置运行时。你需要自己选择一个社区提供的运行时库。最流行的运行时包括：
- <code>tokio</code>: 功能最强大、生态最完善的运行时，适用于网络服务。
- <code>async-std</code>: 模仿标准库 API 的运行时，学习曲线平缓。
- <code>smol</code>: 一个小巧、简单的运行时。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="https://unpkg.com/mermaid@10/dist/mermaid.min.js"></script>
      
        <script src="../assets/mermaid-init.js"></script>
      
    
  </body>
</html>